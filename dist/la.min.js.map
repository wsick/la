{"version":3,"sources":["_version.ts","ellipse.ts","EPSILON.ts","mat3.ts","la.js","padding.ts","vec2.ts","rect.ts"],"names":["la","version","ellipse","cx","cy","rx","ry","phi","flatTangentAngles","va1","Math","atan2","db","da","PI2","va2","PI","ha1","dd","dc","ha2","normalizeAngle","angle","sphi","sin","cphi","cos","e","x","theta","stheta","ctheta","y","point","vec2","create","normal","rotate","tangent","PI1_2","extrema","sa","ea","ac","isContained","_a","EPSILON","mat3","src","dest","Float32Array","copyTo","init","m11","m12","m21","m22","x0","y0","identity","equal","a","b","abs","multiply","a11","a12","a21","a22","ax0","ay0","b11","b12","b21","b22","bx0","by0","inverse","mat","simple_inverse","complex_inverse","transformVec2","vec","transformVec2s","vecs","_i","arguments","length","i","createTranslate","translate","createScale","sx","sy","scale","createRotate","angleRad","c","s","createSkew","angleRadX","angleRadY","tan","preapply","apply","det","isFinite","id","padding","l","t","r","left","top","right","bottom","r1","r2","isEmpty","clone","reverse","orthogonal","normalize","len","sqrt","midpoint","p1","p2","x1","y1","x2","y2","angleBetween","u","v","ux","uy","vx","vy","num","den","acos","isClockwiseTo","v1","v2","nv1","nv2","nx","ny","intersection","s1","d1","s2","d2","x3","y3","x4","y4","xn","yn","rect","width","height","transform","w","h","p3","p4","min","max","union","w1","w2","h1","h2","isContainedIn","test","sl","st","sr","sb","tl","tt","tr","tb","containsPoint","rect1","p","roundOut","floor","ceil","roundIn","grow","shrink"],"mappings":"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","file":"la.min.js","sourcesContent":["module la {\n    export var version = '0.2.4';\n}","namespace la {\n    var PI2 = 2 * Math.PI;\n    var PI1_2 = Math.PI / 2;\n\n    export interface IEllipse {\n        cx: number;\n        cy: number;\n        rx: number;\n        ry: number;\n        phi: number;\n        x(theta: number): number;\n        y(theta: number): number;\n        point(theta: number): Float32Array;\n        normal(theta: number): Float32Array;\n        tangent(theta: number): Float32Array;\n        /// Find ellipse extrema within arc defined by [start angle, end angle] sweeping anti-clockwise/clockwise\n        /// [0] and [1] will be vertical tangents\n        /// [2] and [3] will be horizontal tangents\n        /// If not contained within arc, points will be null\n        extrema(sa: number, ea: number, ac: boolean): Float32Array[];\n    }\n    export function ellipse(cx: number, cy: number, rx: number, ry: number, phi: number): IEllipse {\n        var sphi = Math.sin(phi);\n        var cphi = Math.cos(phi);\n\n        var da = rx * cphi;\n        var db = -ry * sphi;\n        var dc = rx * sphi;\n        var dd = ry * cphi;\n\n        function flatTangentAngles(): number[] {\n            // vertical tangent [tan(theta) = b/a]\n            // 2 angles on opposite side of ellipse\n            var va1 = Math.atan2(db, da);\n            if (va1 < 0)\n                va1 += PI2;\n            var va2 = va1 >= Math.PI ? va1 - Math.PI : va1 + Math.PI;\n\n            // horizontal tangent [tan(theta) = d/c]\n            // 2 angles on opposite side of ellipse\n            var ha1 = Math.atan2(dd, dc);\n            if (ha1 < 0)\n                ha1 += PI2;\n            var ha2 = ha1 >= Math.PI ? ha1 - Math.PI : ha1 + Math.PI;\n\n            return [va1, va2, ha1, ha2];\n        }\n\n        function normalizeAngle(angle: number): number {\n            angle = angle % PI2;\n            if (angle < 0)\n                angle += PI2;\n            return angle;\n        }\n\n        var e = {\n            cx: cx,\n            cy: cy,\n            rx: rx,\n            ry: ry,\n            phi: phi,\n            x(theta: number): number {\n                var stheta = Math.sin(theta);\n                var ctheta = Math.cos(theta);\n                return (cphi * rx * ctheta) + (-sphi * ry * stheta) + cx;\n            },\n            y(theta: number): number {\n                var stheta = Math.sin(theta);\n                var ctheta = Math.cos(theta);\n                return (sphi * rx * ctheta) + (cphi * ry * stheta) + cy;\n            },\n            point(theta: number): Float32Array {\n                return vec2.create(e.x(theta), e.y(theta));\n            },\n            normal(theta: number): Float32Array {\n                return vec2.rotate(e.tangent(theta), -PI1_2);\n            },\n            tangent(theta: number): Float32Array {\n                var stheta = Math.sin(theta);\n                var ctheta = Math.cos(theta);\n                return vec2.create(\n                    (-da * stheta) + (db * ctheta),\n                    (-dc * stheta) + (dd * ctheta)\n                );\n            },\n            extrema(sa: number, ea: number, ac: boolean): Float32Array[] {\n                var da = ea - sa;\n                var sa = normalizeAngle(sa);\n                var ea = normalizeAngle(ea);\n\n                var isContained: (theta: number) => boolean;\n                if (sa < ea) {\n                    if (ac === true) {\n                        isContained = (theta) => (0 <= theta && theta <= sa) || (ea <= theta && theta <= PI2);\n                    } else {\n                        isContained = (theta) => sa <= theta && theta <= ea;\n                    }\n                } else if (sa > ea) {\n                    if (ac === true) {\n                        isContained = (theta) => ea <= theta && theta <= sa;\n                    } else {\n                        isContained = (theta) => (0 <= theta && theta <= ea) || (sa <= theta && theta <= PI2);\n                    }\n                } else {\n                    if (da > 0) {\n                        isContained = (theta) => true;\n                    } else {\n                        isContained = (theta) => false;\n                    }\n                }\n\n                var [va1, va2, ha1, ha2] = flatTangentAngles();\n                return [\n                    (isContained(va1)) ? e.point(va1) : null,\n                    (isContained(va2)) ? e.point(va2) : null,\n                    (isContained(ha1)) ? e.point(ha1) : null,\n                    (isContained(ha2)) ? e.point(ha2) : null,\n                ];\n            }\n        };\n        return e;\n    }\n}\n","namespace la {\n    export var EPSILON = 1E-6;\n}","namespace la.mat3 {\n    /// NOTE:\n    ///     Row-major order\n    ///     [m11, m12, m21, m22, x0, y0]\n    export function create(src?: number[]|Float32Array): Float32Array {\n        var dest = new Float32Array(6);\n\n        if (src) {\n            dest[0] = src[0];\n            dest[1] = src[1];\n            dest[2] = src[2];\n            dest[3] = src[3];\n            dest[4] = src[4];\n            dest[5] = src[5];\n        } else {\n            dest[0] = dest[1] = dest[2] = dest[3] = dest[4] = dest[5] = 0;\n        }\n\n        return dest;\n    }\n\n    export function copyTo(src: Float32Array, dest: Float32Array): Float32Array {\n        dest[0] = src[0];\n        dest[1] = src[1];\n        dest[2] = src[2];\n        dest[3] = src[3];\n        dest[4] = src[4];\n        dest[5] = src[5];\n        return dest;\n    }\n\n    export function init(dest: Float32Array, m11: number, m12: number, m21: number, m22: number, x0: number, y0: number): Float32Array {\n        dest[0] = m11;\n        dest[1] = m12;\n        dest[2] = m21;\n        dest[3] = m22;\n        dest[4] = x0;\n        dest[5] = y0;\n        return dest;\n    }\n\n    export function identity(dest?: Float32Array): Float32Array {\n        if (!dest) dest = create();\n        dest[0] = 1;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 1;\n        dest[4] = 0;\n        dest[5] = 0;\n        return dest;\n    }\n\n    export function equal(a: Float32Array, b: Float32Array): boolean {\n        return a === b || (\n                Math.abs(a[0] - b[0]) < EPSILON &&\n                Math.abs(a[1] - b[1]) < EPSILON &&\n                Math.abs(a[2] - b[2]) < EPSILON &&\n                Math.abs(a[3] - b[3]) < EPSILON &&\n                Math.abs(a[4] - b[4]) < EPSILON &&\n                Math.abs(a[5] - b[5]) < EPSILON\n            );\n    }\n\n    // dest = a * b\n    export function multiply(a: Float32Array, b: Float32Array, dest?: Float32Array): Float32Array {\n        if (!dest) dest = a;\n        var a11 = a[0], a12 = a[1],\n            a21 = a[2], a22 = a[3],\n            ax0 = a[4], ay0 = a[5],\n            b11 = b[0], b12 = b[1],\n            b21 = b[2], b22 = b[3],\n            bx0 = b[4], by0 = b[5];\n\n        dest[0] = a11 * b11 + a12 * b21;\n        dest[1] = a11 * b12 + a12 * b22;\n\n        dest[2] = a21 * b11 + a22 * b21;\n        dest[3] = a21 * b12 + a22 * b22;\n\n        dest[4] = a11 * bx0 + a12 * by0 + ax0;\n        dest[5] = a21 * bx0 + a22 * by0 + ay0;\n\n        return dest;\n    }\n\n    export function inverse(mat: Float32Array, dest?: Float32Array): Float32Array {\n        if (Math.abs(mat[1]) < EPSILON && Math.abs(mat[2]) < EPSILON) //Simple scaling/translation matrix\n            return simple_inverse(mat, dest);\n        else\n            return complex_inverse(mat, dest);\n    }\n\n    export function transformVec2(mat: Float32Array, vec: Float32Array, dest?: Float32Array): Float32Array {\n        if (!dest) dest = vec;\n        var x = vec[0],\n            y = vec[1];\n        dest[0] = (mat[0] * x) + (mat[1] * y) + mat[4];\n        dest[1] = (mat[2] * x) + (mat[3] * y) + mat[5];\n        return dest;\n    }\n\n    export function transformVec2s(mat: Float32Array, ...vecs: Float32Array[]) {\n        for (var i = vecs.length - 1; i >= 0; i--) {\n            transformVec2(mat, vecs[i]);\n        }\n    }\n\n    export function createTranslate(x: number, y: number, dest?: Float32Array): Float32Array {\n        if (!dest) dest = create();\n        dest[0] = 1;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 1;\n        dest[4] = x;\n        dest[5] = y;\n        return dest;\n    }\n\n    export function translate(mat: Float32Array, x: number, y: number): Float32Array {\n        mat[4] += x;\n        mat[5] += y;\n        return mat;\n    }\n\n    export function createScale(sx: number, sy: number, dest?: Float32Array): Float32Array {\n        if (!dest) dest = create();\n        dest[0] = sx;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = sy;\n        dest[4] = 0;\n        dest[5] = 0;\n        return dest;\n    }\n\n    export function scale(mat: Float32Array, sx: number, sy: number): Float32Array {\n        mat[0] *= sx;\n        mat[2] *= sx;\n        mat[4] *= sx;\n\n        mat[1] *= sy;\n        mat[3] *= sy;\n        mat[5] *= sy;\n        return mat;\n    }\n\n    export function createRotate(angleRad: number, dest?: Float32Array): Float32Array {\n        if (!dest) dest = create();\n        var c = Math.cos(angleRad);\n        var s = Math.sin(angleRad);\n        dest[0] = c;\n        dest[1] = -s;\n        dest[2] = s;\n        dest[3] = c;\n        dest[4] = 0;\n        dest[5] = 0;\n        return dest;\n    }\n\n    export function createSkew(angleRadX: number, angleRadY: number, dest?: Float32Array): Float32Array {\n        if (!dest) dest = create();\n        dest[0] = 1;\n        dest[1] = Math.tan(angleRadX);\n        dest[2] = Math.tan(angleRadY);\n        dest[3] = 1;\n        dest[4] = 0;\n        dest[5] = 0;\n        return dest;\n    }\n\n    export function preapply(dest: Float32Array, mat: Float32Array): Float32Array {\n        return multiply(dest, mat, dest);\n    }\n\n    export function apply(dest: Float32Array, mat: Float32Array): Float32Array {\n        return multiply(mat, dest, dest);\n    }\n\n    function simple_inverse(mat: Float32Array, dest?: Float32Array): Float32Array {\n        var m11 = mat[0];\n        if (Math.abs(m11) < EPSILON)\n            return null;\n\n        var m22 = mat[3];\n        if (Math.abs(m22) < EPSILON)\n            return null;\n\n        if (!dest) {\n            dest = mat;\n        } else {\n            dest[1] = mat[1];\n            dest[2] = mat[2];\n        }\n\n        var x0 = -mat[4];\n        var y0 = -mat[5];\n        if (Math.abs(m11 - 1) > EPSILON) {\n            m11 = 1 / m11;\n            x0 *= m11;\n        }\n        if (Math.abs(m22 - 1) > EPSILON) {\n            m22 = 1 / m22;\n            y0 *= m22;\n        }\n\n        dest[0] = m11;\n        dest[3] = m22;\n        dest[4] = x0;\n        dest[5] = y0;\n        return dest;\n    }\n\n    function complex_inverse(mat: Float32Array, dest?: Float32Array): Float32Array {\n        if (!dest) dest = mat;\n\n        var m11 = mat[0], m12 = mat[1],\n            m21 = mat[2], m22 = mat[3];\n\n        //inv(A) = 1/det(A) * adj(A)\n        var det = m11 * m22 - m12 * m21;\n        if (det === 0 || !isFinite(det))\n            return null;\n        var id = 1 / det;\n\n        var x0 = mat[4], y0 = mat[5];\n\n        dest[0] = m22 * id;\n        dest[1] = -m12 * id;\n        dest[2] = -m21 * id;\n        dest[3] = m11 * id;\n        dest[4] = (m21 * y0 - m22 * x0) * id;\n        dest[5] = (m12 * x0 - m11 * y0) * id;\n        return dest;\n    }\n}","var la;\n(function (la) {\n    la.version = '0.2.4';\n})(la || (la = {}));\nvar la;\n(function (la) {\n    var PI2 = 2 * Math.PI;\n    var PI1_2 = Math.PI / 2;\n    function ellipse(cx, cy, rx, ry, phi) {\n        var sphi = Math.sin(phi);\n        var cphi = Math.cos(phi);\n        var da = rx * cphi;\n        var db = -ry * sphi;\n        var dc = rx * sphi;\n        var dd = ry * cphi;\n        function flatTangentAngles() {\n            var va1 = Math.atan2(db, da);\n            if (va1 < 0)\n                va1 += PI2;\n            var va2 = va1 >= Math.PI ? va1 - Math.PI : va1 + Math.PI;\n            var ha1 = Math.atan2(dd, dc);\n            if (ha1 < 0)\n                ha1 += PI2;\n            var ha2 = ha1 >= Math.PI ? ha1 - Math.PI : ha1 + Math.PI;\n            return [va1, va2, ha1, ha2];\n        }\n        function normalizeAngle(angle) {\n            angle = angle % PI2;\n            if (angle < 0)\n                angle += PI2;\n            return angle;\n        }\n        var e = {\n            cx: cx,\n            cy: cy,\n            rx: rx,\n            ry: ry,\n            phi: phi,\n            x: function (theta) {\n                var stheta = Math.sin(theta);\n                var ctheta = Math.cos(theta);\n                return (cphi * rx * ctheta) + (-sphi * ry * stheta) + cx;\n            },\n            y: function (theta) {\n                var stheta = Math.sin(theta);\n                var ctheta = Math.cos(theta);\n                return (sphi * rx * ctheta) + (cphi * ry * stheta) + cy;\n            },\n            point: function (theta) {\n                return la.vec2.create(e.x(theta), e.y(theta));\n            },\n            normal: function (theta) {\n                return la.vec2.rotate(e.tangent(theta), -PI1_2);\n            },\n            tangent: function (theta) {\n                var stheta = Math.sin(theta);\n                var ctheta = Math.cos(theta);\n                return la.vec2.create((-da * stheta) + (db * ctheta), (-dc * stheta) + (dd * ctheta));\n            },\n            extrema: function (sa, ea, ac) {\n                var da = ea - sa;\n                var sa = normalizeAngle(sa);\n                var ea = normalizeAngle(ea);\n                var isContained;\n                if (sa < ea) {\n                    if (ac === true) {\n                        isContained = function (theta) { return (0 <= theta && theta <= sa) || (ea <= theta && theta <= PI2); };\n                    }\n                    else {\n                        isContained = function (theta) { return sa <= theta && theta <= ea; };\n                    }\n                }\n                else if (sa > ea) {\n                    if (ac === true) {\n                        isContained = function (theta) { return ea <= theta && theta <= sa; };\n                    }\n                    else {\n                        isContained = function (theta) { return (0 <= theta && theta <= ea) || (sa <= theta && theta <= PI2); };\n                    }\n                }\n                else {\n                    if (da > 0) {\n                        isContained = function (theta) { return true; };\n                    }\n                    else {\n                        isContained = function (theta) { return false; };\n                    }\n                }\n                var _a = flatTangentAngles(), va1 = _a[0], va2 = _a[1], ha1 = _a[2], ha2 = _a[3];\n                return [\n                    (isContained(va1)) ? e.point(va1) : null,\n                    (isContained(va2)) ? e.point(va2) : null,\n                    (isContained(ha1)) ? e.point(ha1) : null,\n                    (isContained(ha2)) ? e.point(ha2) : null,\n                ];\n            }\n        };\n        return e;\n    }\n    la.ellipse = ellipse;\n})(la || (la = {}));\nvar la;\n(function (la) {\n    la.EPSILON = 1E-6;\n})(la || (la = {}));\nvar la;\n(function (la) {\n    var mat3;\n    (function (mat3) {\n        function create(src) {\n            var dest = new Float32Array(6);\n            if (src) {\n                dest[0] = src[0];\n                dest[1] = src[1];\n                dest[2] = src[2];\n                dest[3] = src[3];\n                dest[4] = src[4];\n                dest[5] = src[5];\n            }\n            else {\n                dest[0] = dest[1] = dest[2] = dest[3] = dest[4] = dest[5] = 0;\n            }\n            return dest;\n        }\n        mat3.create = create;\n        function copyTo(src, dest) {\n            dest[0] = src[0];\n            dest[1] = src[1];\n            dest[2] = src[2];\n            dest[3] = src[3];\n            dest[4] = src[4];\n            dest[5] = src[5];\n            return dest;\n        }\n        mat3.copyTo = copyTo;\n        function init(dest, m11, m12, m21, m22, x0, y0) {\n            dest[0] = m11;\n            dest[1] = m12;\n            dest[2] = m21;\n            dest[3] = m22;\n            dest[4] = x0;\n            dest[5] = y0;\n            return dest;\n        }\n        mat3.init = init;\n        function identity(dest) {\n            if (!dest)\n                dest = create();\n            dest[0] = 1;\n            dest[1] = 0;\n            dest[2] = 0;\n            dest[3] = 1;\n            dest[4] = 0;\n            dest[5] = 0;\n            return dest;\n        }\n        mat3.identity = identity;\n        function equal(a, b) {\n            return a === b || (Math.abs(a[0] - b[0]) < la.EPSILON &&\n                Math.abs(a[1] - b[1]) < la.EPSILON &&\n                Math.abs(a[2] - b[2]) < la.EPSILON &&\n                Math.abs(a[3] - b[3]) < la.EPSILON &&\n                Math.abs(a[4] - b[4]) < la.EPSILON &&\n                Math.abs(a[5] - b[5]) < la.EPSILON);\n        }\n        mat3.equal = equal;\n        function multiply(a, b, dest) {\n            if (!dest)\n                dest = a;\n            var a11 = a[0], a12 = a[1], a21 = a[2], a22 = a[3], ax0 = a[4], ay0 = a[5], b11 = b[0], b12 = b[1], b21 = b[2], b22 = b[3], bx0 = b[4], by0 = b[5];\n            dest[0] = a11 * b11 + a12 * b21;\n            dest[1] = a11 * b12 + a12 * b22;\n            dest[2] = a21 * b11 + a22 * b21;\n            dest[3] = a21 * b12 + a22 * b22;\n            dest[4] = a11 * bx0 + a12 * by0 + ax0;\n            dest[5] = a21 * bx0 + a22 * by0 + ay0;\n            return dest;\n        }\n        mat3.multiply = multiply;\n        function inverse(mat, dest) {\n            if (Math.abs(mat[1]) < la.EPSILON && Math.abs(mat[2]) < la.EPSILON)\n                return simple_inverse(mat, dest);\n            else\n                return complex_inverse(mat, dest);\n        }\n        mat3.inverse = inverse;\n        function transformVec2(mat, vec, dest) {\n            if (!dest)\n                dest = vec;\n            var x = vec[0], y = vec[1];\n            dest[0] = (mat[0] * x) + (mat[1] * y) + mat[4];\n            dest[1] = (mat[2] * x) + (mat[3] * y) + mat[5];\n            return dest;\n        }\n        mat3.transformVec2 = transformVec2;\n        function transformVec2s(mat) {\n            var vecs = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                vecs[_i - 1] = arguments[_i];\n            }\n            for (var i = vecs.length - 1; i >= 0; i--) {\n                transformVec2(mat, vecs[i]);\n            }\n        }\n        mat3.transformVec2s = transformVec2s;\n        function createTranslate(x, y, dest) {\n            if (!dest)\n                dest = create();\n            dest[0] = 1;\n            dest[1] = 0;\n            dest[2] = 0;\n            dest[3] = 1;\n            dest[4] = x;\n            dest[5] = y;\n            return dest;\n        }\n        mat3.createTranslate = createTranslate;\n        function translate(mat, x, y) {\n            mat[4] += x;\n            mat[5] += y;\n            return mat;\n        }\n        mat3.translate = translate;\n        function createScale(sx, sy, dest) {\n            if (!dest)\n                dest = create();\n            dest[0] = sx;\n            dest[1] = 0;\n            dest[2] = 0;\n            dest[3] = sy;\n            dest[4] = 0;\n            dest[5] = 0;\n            return dest;\n        }\n        mat3.createScale = createScale;\n        function scale(mat, sx, sy) {\n            mat[0] *= sx;\n            mat[2] *= sx;\n            mat[4] *= sx;\n            mat[1] *= sy;\n            mat[3] *= sy;\n            mat[5] *= sy;\n            return mat;\n        }\n        mat3.scale = scale;\n        function createRotate(angleRad, dest) {\n            if (!dest)\n                dest = create();\n            var c = Math.cos(angleRad);\n            var s = Math.sin(angleRad);\n            dest[0] = c;\n            dest[1] = -s;\n            dest[2] = s;\n            dest[3] = c;\n            dest[4] = 0;\n            dest[5] = 0;\n            return dest;\n        }\n        mat3.createRotate = createRotate;\n        function createSkew(angleRadX, angleRadY, dest) {\n            if (!dest)\n                dest = create();\n            dest[0] = 1;\n            dest[1] = Math.tan(angleRadX);\n            dest[2] = Math.tan(angleRadY);\n            dest[3] = 1;\n            dest[4] = 0;\n            dest[5] = 0;\n            return dest;\n        }\n        mat3.createSkew = createSkew;\n        function preapply(dest, mat) {\n            return multiply(dest, mat, dest);\n        }\n        mat3.preapply = preapply;\n        function apply(dest, mat) {\n            return multiply(mat, dest, dest);\n        }\n        mat3.apply = apply;\n        function simple_inverse(mat, dest) {\n            var m11 = mat[0];\n            if (Math.abs(m11) < la.EPSILON)\n                return null;\n            var m22 = mat[3];\n            if (Math.abs(m22) < la.EPSILON)\n                return null;\n            if (!dest) {\n                dest = mat;\n            }\n            else {\n                dest[1] = mat[1];\n                dest[2] = mat[2];\n            }\n            var x0 = -mat[4];\n            var y0 = -mat[5];\n            if (Math.abs(m11 - 1) > la.EPSILON) {\n                m11 = 1 / m11;\n                x0 *= m11;\n            }\n            if (Math.abs(m22 - 1) > la.EPSILON) {\n                m22 = 1 / m22;\n                y0 *= m22;\n            }\n            dest[0] = m11;\n            dest[3] = m22;\n            dest[4] = x0;\n            dest[5] = y0;\n            return dest;\n        }\n        function complex_inverse(mat, dest) {\n            if (!dest)\n                dest = mat;\n            var m11 = mat[0], m12 = mat[1], m21 = mat[2], m22 = mat[3];\n            var det = m11 * m22 - m12 * m21;\n            if (det === 0 || !isFinite(det))\n                return null;\n            var id = 1 / det;\n            var x0 = mat[4], y0 = mat[5];\n            dest[0] = m22 * id;\n            dest[1] = -m12 * id;\n            dest[2] = -m21 * id;\n            dest[3] = m11 * id;\n            dest[4] = (m21 * y0 - m22 * x0) * id;\n            dest[5] = (m12 * x0 - m11 * y0) * id;\n            return dest;\n        }\n    })(mat3 = la.mat3 || (la.mat3 = {}));\n})(la || (la = {}));\nvar la;\n(function (la) {\n    var padding;\n    (function (padding) {\n        function init(l, t, r, b, dest) {\n            if (!dest)\n                return { left: l, top: t, right: r, bottom: b };\n            dest.left = l;\n            dest.top = t;\n            dest.right = r;\n            dest.bottom = b;\n            return dest;\n        }\n        padding.init = init;\n        function copyTo(src, dest) {\n            if (!dest) {\n                return {\n                    left: src.left,\n                    top: src.top,\n                    right: src.right,\n                    bottom: src.bottom\n                };\n            }\n            else {\n                dest.left = src.left;\n                dest.top = src.top;\n                dest.right = src.right;\n                dest.bottom = src.bottom;\n                return dest;\n            }\n        }\n        padding.copyTo = copyTo;\n        function equal(r1, r2) {\n            return r1.left === r2.left\n                && r1.top === r2.top\n                && r1.right === r2.right\n                && r1.bottom === r2.bottom;\n        }\n        padding.equal = equal;\n        function isEmpty(src) {\n            return src.left === 0\n                && src.top === 0\n                && src.right === 0\n                && src.bottom === 0;\n        }\n        padding.isEmpty = isEmpty;\n    })(padding = la.padding || (la.padding = {}));\n})(la || (la = {}));\nvar la;\n(function (la) {\n    var vec2;\n    (function (vec2) {\n        function create(x, y) {\n            var dest = new Float32Array(2);\n            dest[0] = x;\n            dest[1] = y;\n            return dest;\n        }\n        vec2.create = create;\n        function init(x, y, dest) {\n            if (!dest)\n                dest = new Float32Array(2);\n            dest[0] = x;\n            dest[1] = y;\n            return dest;\n        }\n        vec2.init = init;\n        function clone(src, dest) {\n            return init(src[0], src[1], dest);\n        }\n        vec2.clone = clone;\n        function reverse(src, dest) {\n            if (!dest)\n                dest = src;\n            dest[0] = -src[0];\n            dest[1] = -src[1];\n            return dest;\n        }\n        vec2.reverse = reverse;\n        function orthogonal(src, dest) {\n            if (!dest)\n                dest = src;\n            var x = src[0], y = src[1];\n            dest[0] = -y;\n            dest[1] = x;\n            return dest;\n        }\n        vec2.orthogonal = orthogonal;\n        function normalize(src, dest) {\n            if (!dest)\n                dest = src;\n            var x = src[0], y = src[1];\n            var len = Math.sqrt(x * x + y * y);\n            dest[0] = x / len;\n            dest[1] = y / len;\n            return dest;\n        }\n        vec2.normalize = normalize;\n        function rotate(src, theta, dest) {\n            if (!dest)\n                dest = src;\n            var c = Math.cos(theta);\n            var s = Math.sin(theta);\n            var x = src[0];\n            var y = src[1];\n            dest[0] = x * c - y * s;\n            dest[1] = x * s + y * c;\n            return dest;\n        }\n        vec2.rotate = rotate;\n        function midpoint(p1, p2, dest) {\n            if (!dest)\n                dest = p1;\n            var x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1];\n            dest[0] = (x1 + x2) / 2.0;\n            dest[1] = (y1 + y2) / 2.0;\n            return dest;\n        }\n        vec2.midpoint = midpoint;\n        function angleBetween(u, v) {\n            var ux = u[0], uy = u[1], vx = v[0], vy = v[1];\n            var num = ux * vx + uy * vy;\n            var den = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n            return Math.acos(num / den);\n        }\n        vec2.angleBetween = angleBetween;\n        function isClockwiseTo(v1, v2) {\n            var theta = angleBetween(v1, v2);\n            var nv1 = normalize(clone(v1));\n            var nv2 = normalize(clone(v2));\n            rotate(nv1, theta);\n            var nx = Math.abs(nv1[0] - nv2[0]);\n            var ny = Math.abs(nv1[1] - nv2[1]);\n            return nx < la.EPSILON\n                && ny < la.EPSILON;\n        }\n        vec2.isClockwiseTo = isClockwiseTo;\n        function intersection(s1, d1, s2, d2) {\n            var x1 = s1[0];\n            var y1 = s1[1];\n            var x2 = x1 + d1[0];\n            var y2 = y1 + d1[1];\n            var x3 = s2[0];\n            var y3 = s2[1];\n            var x4 = x3 + d2[0];\n            var y4 = y3 + d2[1];\n            var det = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n            if (det === 0)\n                return null;\n            var xn = ((x1 * y2 - y1 * x2) * (x3 - x4)) - ((x1 - x2) * (x3 * y4 - y3 * x4));\n            var yn = ((x1 * y2 - y1 * x2) * (y3 - y4)) - ((y1 - y2) * (x3 * y4 - y3 * x4));\n            return vec2.create(xn / det, yn / det);\n        }\n        vec2.intersection = intersection;\n    })(vec2 = la.vec2 || (la.vec2 = {}));\n})(la || (la = {}));\nvar la;\n(function (la) {\n    var rect;\n    (function (rect) {\n        function init(x, y, width, height, dest) {\n            if (!dest)\n                return { x: x, y: y, width: width, height: height };\n            dest.x = x;\n            dest.y = y;\n            dest.width = width;\n            dest.height = height;\n            return dest;\n        }\n        rect.init = init;\n        function copyTo(src, dest) {\n            if (!dest) {\n                return {\n                    x: src.x,\n                    y: src.y,\n                    width: src.width,\n                    height: src.height\n                };\n            }\n            else {\n                dest.x = src.x;\n                dest.y = src.y;\n                dest.width = src.width;\n                dest.height = src.height;\n                return dest;\n            }\n        }\n        rect.copyTo = copyTo;\n        var p1 = la.vec2.create(0, 0);\n        var p2 = la.vec2.create(0, 0);\n        var p3 = la.vec2.create(0, 0);\n        var p4 = la.vec2.create(0, 0);\n        function transform(src, transform, dest) {\n            if (!transform)\n                return dest;\n            if (!dest)\n                dest = { x: 0, y: 0, width: 0, height: 0 };\n            var x = src.x;\n            var y = src.y;\n            var w = src.width;\n            var h = src.height;\n            la.vec2.init(x, y, p1);\n            la.vec2.init(x + w, y, p2);\n            la.vec2.init(x + w, y + h, p3);\n            la.vec2.init(x, y + h, p4);\n            la.mat3.transformVec2(transform, p1);\n            la.mat3.transformVec2(transform, p2);\n            la.mat3.transformVec2(transform, p3);\n            la.mat3.transformVec2(transform, p4);\n            var l = Math.min(p1[0], p2[0], p3[0], p4[0]);\n            var t = Math.min(p1[1], p2[1], p3[1], p4[1]);\n            var r = Math.max(p1[0], p2[0], p3[0], p4[0]);\n            var b = Math.max(p1[1], p2[1], p3[1], p4[1]);\n            dest.x = l;\n            dest.y = t;\n            dest.width = r - l;\n            dest.height = b - t;\n            return dest;\n        }\n        rect.transform = transform;\n        function equal(r1, r2) {\n            return r1.x === r2.x\n                && r1.y === r2.y\n                && r1.width === r2.width\n                && r1.height === r2.height;\n        }\n        rect.equal = equal;\n        function isEmpty(src) {\n            return src.width === 0\n                || src.height === 0;\n        }\n        rect.isEmpty = isEmpty;\n        function union(r1, r2, dest) {\n            if (!dest)\n                dest = r1;\n            if (r2.width <= 0 || r2.height <= 0)\n                return dest;\n            if (dest.width <= 0 || dest.height <= 0)\n                return rect.copyTo(r2, dest);\n            var x1 = r1.x, x2 = r2.x, y1 = r1.y, y2 = r2.y, w1 = r1.width, w2 = r2.width, h1 = r1.height, h2 = r2.height;\n            dest.x = Math.min(x1, x2);\n            dest.y = Math.min(y1, y2);\n            dest.width = Math.max(x1 + w1, x2 + w2) - dest.x;\n            dest.height = Math.max(y1 + h1, y2 + h2) - dest.y;\n            return dest;\n        }\n        rect.union = union;\n        function intersection(r1, r2, dest) {\n            if (!dest)\n                dest = r1;\n            var x = Math.max(r1.x, r2.x);\n            var y = Math.max(r1.y, r2.y);\n            dest.width = Math.max(0, Math.min(r1.x + r1.width, r2.x + r2.width) - x);\n            dest.height = Math.max(0, Math.min(r1.y + r1.height, r2.y + r2.height) - y);\n            dest.x = x;\n            dest.y = y;\n            return dest;\n        }\n        rect.intersection = intersection;\n        function isContainedIn(src, test) {\n            var sl = src.x;\n            var st = src.y;\n            var sr = src.x + src.width;\n            var sb = src.y + src.height;\n            var tl = test.x;\n            var tt = test.y;\n            var tr = test.x + test.width;\n            var tb = test.y + test.height;\n            if (sl < tl || st < tt || sl > tr || st > tb)\n                return false;\n            if (sr < tl || sb < tt || sr > tr || sb > tb)\n                return false;\n            return true;\n        }\n        rect.isContainedIn = isContainedIn;\n        function containsPoint(rect1, p) {\n            return rect1.x <= p.x\n                && rect1.y <= p.y\n                && (rect1.x + rect1.width) >= p.x\n                && (rect1.y + rect1.height) >= p.y;\n        }\n        rect.containsPoint = containsPoint;\n        function roundOut(dest) {\n            var x = Math.floor(dest.x);\n            var y = Math.floor(dest.y);\n            dest.width = Math.ceil(dest.x + dest.width) - x;\n            dest.height = Math.ceil(dest.y + dest.height) - y;\n            dest.x = x;\n            dest.y = y;\n        }\n        rect.roundOut = roundOut;\n        function roundIn(dest) {\n            var x = Math.ceil(dest.x);\n            var y = Math.ceil(dest.y);\n            dest.width = Math.floor(dest.x + dest.width) - x;\n            dest.height = Math.floor(dest.y + dest.height) - y;\n            dest.x = x;\n            dest.y = y;\n            return dest;\n        }\n        rect.roundIn = roundIn;\n        function grow(src, padding, dest) {\n            if (!dest)\n                dest = src;\n            dest.x -= padding.left;\n            dest.y -= padding.top;\n            dest.width += padding.left + padding.right;\n            dest.height += padding.top + padding.bottom;\n        }\n        rect.grow = grow;\n        function shrink(src, padding, dest) {\n            if (!dest)\n                dest = src;\n            dest.x += padding.left;\n            dest.y += padding.top;\n            dest.width -= padding.left + padding.right;\n            dest.height -= padding.top + padding.bottom;\n        }\n        rect.shrink = shrink;\n    })(rect = la.rect || (la.rect = {}));\n})(la || (la = {}));\n","namespace la.padding {\n    export function init(l: number, t: number, r: number, b: number, dest?: IPadding): IPadding {\n        if (!dest)\n            return {left: l, top: t, right: r, bottom: b};\n        dest.left = l;\n        dest.top = t;\n        dest.right = r;\n        dest.bottom = b;\n        return dest;\n    }\n\n    export function copyTo(src: IPadding, dest?: IPadding): IPadding {\n        if (!dest) {\n            return {\n                left: src.left,\n                top: src.top,\n                right: src.right,\n                bottom: src.bottom\n            };\n        } else {\n            dest.left = src.left;\n            dest.top = src.top;\n            dest.right = src.right;\n            dest.bottom = src.bottom;\n            return dest;\n        }\n    }\n\n    export function equal(r1: IPadding, r2: IPadding): boolean {\n        return r1.left === r2.left\n            && r1.top === r2.top\n            && r1.right === r2.right\n            && r1.bottom === r2.bottom;\n    }\n\n    export function isEmpty(src: IPadding): boolean {\n        return src.left === 0\n            && src.top === 0\n            && src.right === 0\n            && src.bottom === 0;\n    }\n}","namespace la.vec2 {\n    export function create(x: number, y: number): Float32Array {\n        var dest = new Float32Array(2);\n        dest[0] = x;\n        dest[1] = y;\n        return dest;\n    }\n\n    export function init(x: number, y: number, dest?: Float32Array): Float32Array {\n        if (!dest) dest = new Float32Array(2);\n        dest[0] = x;\n        dest[1] = y;\n        return dest;\n    }\n\n    export function clone(src: Float32Array, dest?: Float32Array): Float32Array {\n        return init(src[0], src[1], dest);\n    }\n\n    export function reverse(src: Float32Array, dest?: Float32Array): Float32Array {\n        if (!dest) dest = src;\n        dest[0] = -src[0];\n        dest[1] = -src[1];\n        return dest;\n    }\n\n    /// Equivalent of rotating 90 degrees clockwise (screen space)\n    export function orthogonal(src: Float32Array, dest?: Float32Array): Float32Array {\n        if (!dest) dest = src;\n        var x = src[0],\n            y = src[1];\n        dest[0] = -y;\n        dest[1] = x;\n        return dest;\n    }\n\n    export function normalize(src: Float32Array, dest?: Float32Array): Float32Array {\n        if (!dest) dest = src;\n        var x = src[0],\n            y = src[1];\n        var len = Math.sqrt(x * x + y * y);\n        dest[0] = x / len;\n        dest[1] = y / len;\n        return dest;\n    }\n\n    /// Rotates a vector(v) by angle(theta) clockwise(screen space) ...which is counter-clockwise in coordinate space\n    export function rotate(src: Float32Array, theta: number, dest?: Float32Array): Float32Array {\n        if (!dest) dest = src;\n        var c = Math.cos(theta);\n        var s = Math.sin(theta);\n        var x = src[0];\n        var y = src[1];\n        dest[0] = x * c - y * s;\n        dest[1] = x * s + y * c;\n        return dest;\n    }\n\n    /// Computes the midpoint between 2 points\n    export function midpoint(p1: Float32Array, p2: Float32Array, dest?: Float32Array): Float32Array {\n        if (!dest) dest = p1;\n        var x1 = p1[0],\n            y1 = p1[1],\n            x2 = p2[0],\n            y2 = p2[1];\n        dest[0] = (x1 + x2) / 2.0;\n        dest[1] = (y1 + y2) / 2.0;\n        return dest;\n    }\n\n    /// Returns smallest angle (in radians) between 2 vectors\n    export function angleBetween(u: Float32Array, v: Float32Array): number {\n        var ux = u[0],\n            uy = u[1],\n            vx = v[0],\n            vy = v[1];\n        var num = ux * vx + uy * vy;\n        var den = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n        return Math.acos(num / den);\n    }\n\n    /// By rotating from vector(v1) to vector(v2), tests whether that angle is clockwise (screen space)\n    export function isClockwiseTo(v1: Float32Array, v2: Float32Array): boolean {\n        var theta = angleBetween(v1, v2);\n        var nv1 = normalize(clone(v1));\n        var nv2 = normalize(clone(v2));\n        rotate(nv1, theta);\n        var nx = Math.abs(nv1[0] - nv2[0]);\n        var ny = Math.abs(nv1[1] - nv2[1]);\n        return nx < EPSILON\n            && ny < EPSILON;\n    }\n\n    /// Finds intersection of v1(s1 + t(d1)) and v2(s2 + t(d2))\n    export function intersection(s1: Float32Array, d1: Float32Array, s2: Float32Array, d2: Float32Array): Float32Array {\n        var x1 = s1[0];\n        var y1 = s1[1];\n        var x2 = x1 + d1[0];\n        var y2 = y1 + d1[1];\n\n        var x3 = s2[0];\n        var y3 = s2[1];\n        var x4 = x3 + d2[0];\n        var y4 = y3 + d2[1];\n\n        var det = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (det === 0)\n            return null;\n\n        var xn = ((x1 * y2 - y1 * x2) * (x3 - x4)) - ((x1 - x2) * (x3 * y4 - y3 * x4));\n        var yn = ((x1 * y2 - y1 * x2) * (y3 - y4)) - ((y1 - y2) * (x3 * y4 - y3 * x4));\n        return vec2.create(xn / det, yn / det);\n    }\n}","/// <reference path=\"vec2\" />\n\nnamespace la.rect {\n    export function init(x: number, y: number, width: number, height: number, dest?: IRect): IRect {\n        if (!dest)\n            return {x: x, y: y, width: width, height: height};\n        dest.x = x;\n        dest.y = y;\n        dest.width = width;\n        dest.height = height;\n        return dest;\n    }\n\n    export function copyTo(src: IRect, dest?: IRect): IRect {\n        if (!dest) {\n            return {\n                x: src.x,\n                y: src.y,\n                width: src.width,\n                height: src.height\n            };\n        } else {\n            dest.x = src.x;\n            dest.y = src.y;\n            dest.width = src.width;\n            dest.height = src.height;\n            return dest;\n        }\n    }\n\n    var p1 = vec2.create(0, 0);\n    var p2 = vec2.create(0, 0);\n    var p3 = vec2.create(0, 0);\n    var p4 = vec2.create(0, 0);\n\n    export function transform(src: IRect, transform: Float32Array, dest?: IRect): IRect {\n        if (!transform)\n            return dest;\n        if (!dest)\n            dest = <IRect>{x: 0, y: 0, width: 0, height: 0};\n\n        var x = src.x;\n        var y = src.y;\n        var w = src.width;\n        var h = src.height;\n\n        vec2.init(x, y, p1);\n        vec2.init(x + w, y, p2);\n        vec2.init(x + w, y + h, p3);\n        vec2.init(x, y + h, p4);\n\n        mat3.transformVec2(transform, p1);\n        mat3.transformVec2(transform, p2);\n        mat3.transformVec2(transform, p3);\n        mat3.transformVec2(transform, p4);\n\n        var l = Math.min(p1[0], p2[0], p3[0], p4[0]);\n        var t = Math.min(p1[1], p2[1], p3[1], p4[1]);\n        var r = Math.max(p1[0], p2[0], p3[0], p4[0]);\n        var b = Math.max(p1[1], p2[1], p3[1], p4[1]);\n\n        dest.x = l;\n        dest.y = t;\n        dest.width = r - l;\n        dest.height = b - t;\n        return dest;\n    }\n\n    export function equal(r1: IRect, r2: IRect): boolean {\n        return r1.x === r2.x\n            && r1.y === r2.y\n            && r1.width === r2.width\n            && r1.height === r2.height;\n    }\n\n    export function isEmpty(src: IRect): boolean {\n        return src.width === 0\n            || src.height === 0;\n    }\n\n    // NOTE: If dest is not specified, r1 will be used dest\n    export function union(r1: IRect, r2: IRect, dest?: IRect): IRect {\n        if (!dest) dest = r1;\n        if (r2.width <= 0 || r2.height <= 0)\n            return dest;\n        if (dest.width <= 0 || dest.height <= 0)\n            return rect.copyTo(r2, dest);\n\n        var x1 = r1.x, x2 = r2.x,\n            y1 = r1.y, y2 = r2.y,\n            w1 = r1.width, w2 = r2.width,\n            h1 = r1.height, h2 = r2.height;\n\n        dest.x = Math.min(x1, x2);\n        dest.y = Math.min(y1, y2);\n        dest.width = Math.max(x1 + w1, x2 + w2) - dest.x;\n        dest.height = Math.max(y1 + h1, y2 + h2) - dest.y;\n        return dest;\n    }\n\n    // NOTE: If dest is not specified, r1 will be used dest\n    export function intersection(r1: IRect, r2: IRect, dest?: IRect): IRect {\n        if (!dest) dest = r1;\n        var x = Math.max(r1.x, r2.x);\n        var y = Math.max(r1.y, r2.y);\n        dest.width = Math.max(0, Math.min(r1.x + r1.width, r2.x + r2.width) - x);\n        dest.height = Math.max(0, Math.min(r1.y + r1.height, r2.y + r2.height) - y);\n        dest.x = x;\n        dest.y = y;\n        return dest;\n    }\n\n    export function isContainedIn(src: IRect, test: IRect): boolean {\n        var sl = src.x;\n        var st = src.y;\n        var sr = src.x + src.width;\n        var sb = src.y + src.height;\n\n        var tl = test.x;\n        var tt = test.y;\n        var tr = test.x + test.width;\n        var tb = test.y + test.height;\n\n        if (sl < tl || st < tt || sl > tr || st > tb) //src top-left is outside test\n            return false;\n        if (sr < tl || sb < tt || sr > tr || sb > tb) //src bottom-right is outside test\n            return false;\n        return true;\n    }\n\n    export function containsPoint(rect1: IRect, p: IPoint): boolean {\n        return rect1.x <= p.x\n            && rect1.y <= p.y\n            && (rect1.x + rect1.width) >= p.x\n            && (rect1.y + rect1.height) >= p.y;\n    }\n\n    export function roundOut(dest: IRect) {\n        var x = Math.floor(dest.x);\n        var y = Math.floor(dest.y);\n        dest.width = Math.ceil(dest.x + dest.width) - x;\n        dest.height = Math.ceil(dest.y + dest.height) - y;\n        dest.x = x;\n        dest.y = y;\n    }\n\n    export function roundIn(dest: IRect) {\n        var x = Math.ceil(dest.x);\n        var y = Math.ceil(dest.y);\n        dest.width = Math.floor(dest.x + dest.width) - x;\n        dest.height = Math.floor(dest.y + dest.height) - y;\n        dest.x = x;\n        dest.y = y;\n        return dest;\n    }\n\n    // NOTE: If dest is not specified, src will be used for dest\n    export function grow(src: IRect, padding: IPadding, dest?: IRect) {\n        if (!dest) dest = src;\n        dest.x -= padding.left;\n        dest.y -= padding.top;\n        dest.width += padding.left + padding.right;\n        dest.height += padding.top + padding.bottom;\n    }\n\n    // NOTE: If dest is not specified, src will be used for dest\n    export function shrink(src: IRect, padding: IPadding, dest?: IRect) {\n        if (!dest) dest = src;\n        dest.x += padding.left;\n        dest.y += padding.top;\n        dest.width -= padding.left + padding.right;\n        dest.height -= padding.top + padding.bottom;\n    }\n}"],"sourceRoot":"./src"}